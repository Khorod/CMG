\documentclass[a4paper,pdf,12pt]{article}

\usepackage[utf8]{inputenc}

\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{tikz}

\usepackage{comment}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{multirow}

\usepackage{natbib}

\usepackage{graphicx}
\usepackage{array}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{rotating}

\usepackage[english]{babel}

\usepackage{url}
\usepackage[a4paper=true]{hyperref}
\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}


\title{Crowd Manipulation Game\\ \normalsize{Game Programming}}
\author{Steven Laan\\UvAnetID: 6036031\\\url{S.Laan@uva.nl} \and Michael Cabot\\UvAnetID: 6047262\\\url{michael.cabot@uva.nl} \and Richard Rozeboom\\UvAnetID: 6173292\\\url{HyperSqual@gmail.com}}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
% TODO background / motivation
Crowd behavior has been of great interest in the field of Artificial Intelligence and the simulation of large amounts of people. Every individual in a group of people has to take  many decisions when navigating through the crowd. People would rather not bump into each other, and will try to leave some space between one another. As each person will have a certain place to be, they will not stand still to avoid bumping into each other but instead will try to steer around each other. This requires estimating when and how much to turn, what speed to move at, and calculating an optimal path to the current destination. In crowd simulation these decisions and estimations have to be made for each individual agent.
%http://www.youtube.com/watch?v=eGYIEvEe7Ks

Crowd manipulation is the intentional use of techniques to control or influence the behavior of a crowd such that they take upon a desired action. In the Crowd Manipulation Game (CMG) the player is equipped with artifacts and special abilities which allows him to manipulate the crowd such that he is able to achieve its goal. The game is somewhat inspired by the upcoming game Watchdogs\ref{watchdogs?}, where the player can manipulate the environment by hacking devices such as cell phones and stoplights. In CMG the player will be able to 'hack' ATM machines, making them spit out money in the environment, and civilians will be eager to pick this money up.

% TODO explain pygame
The game is made using the open source Pygame toolkit\footnote{\url{http://www.pygame.org}}: a set of Python modules designed for writing games. Pygame allows for functions that are typically used in the making of games, such as support for sprites, collision, rendering and the likes. 

Section \ref{sec:Design} will discuss the graphical design of the CMG and section \ref{sec:Rendering} will discuss how all the visuals are rendered. In section \ref{sec:Collision Detection} our collision detection is detailed. Section \ref{sec:Path Planning} discusses two approaches to path planning and section \ref{sec:Steering Behavior} explains two approaches to steering behavior. Section \ref{sec:Gameplay} gives an overview of the current state of the game and sections \ref{sec:Discussion} and \ref{sec:Future Work} discuss possible adjustments and extensions. Finally, section \ref{sec:Conclusion} concludes our work.

\section{Design}
\label{sec:Design}
% TODO pixal art, \ref{fig:player}

\begin{figure}[h!]
\centering
\includegraphics[width = 1.0 \textwidth]{../img/player.png}
\caption{Player sprites.}
\label{fig:player}
\end{figure}

\section{Rendering}
\label{sec:Rendering}
\includegraphics[width = 1.0 \textwidth]{../img/ground_test.png}

% TODO tileset

\section{Collision Detection}
\label{sec:Collision Detection}
As soon as the rendering worked, we started on the collision detection. As you don't want your player to be able to walk through walls. Each sprite has a rectangle that represents the boundaries of the object. A collision is detected by determining whether there is an overlap between two rectangles. The overlap between two rectangles is calculated by pygame's collidesrect(). In some cases it is desirable to inflate the rectangle to detect a collision before the objects actually collide,

An object is able to move in a direction if it does not result in a collision. If the object moves both horizontally and vertically, then the object is only moved in the direction that does not cause a collision. For example, an object that wants to move both upwards and to the right will only move upwards if there is a collision when moving to the right. This way an object can glide over a wall without the player explicitly having to hold only the valid keys. 

At first every collision was treated in a similar fashion. All objects in the game inherited from a superclass named GameObject, thus making collision detection easy because of polymorphism. However, because there were quite a couple of walls, it also made collision detection a tad slow. Therefore we implemented another system that is quite straightforward: whenever walls lie next to each other merge them to create a bigger rectangle, on which the collisions are tested.

Thus there are 2 collision systems:
\begin{enumerate}
\item One system for GameObjects
\item One system for static wall collisions
\end{enumerate}

\section{Path Planning}
\label{sec:Path Planning}

After we created collision detection, we wanted to implement NPCs, non-playable characters. At first these character just walked in a straight line. As this is not very smart and does not get you anywhere, more advanced pathplanning had to be implemented. 

\subsection{Grid-based approach}
One of the simplest solutions was to work with the grid we already got for the collisions. Every point in this grid was connected to its direct neighbors in a graph. Now we could simply use A* to plan a path in this graph. 

The planning of a path involved converting the pixel position of an NPC to the corresponding tile position, as this was the level the collision map was defined on. Then the path could be planned in these tile positions and could be executed by the NPCs.

\subsection{Navigation Mesh}
The former solution did work, albeit it was a bit slow. As the goal was to simulate a crowd, slow pathfinding could really become a problem, when dealing with bigger crowds. Thus a more efficient solution had to be found.

Therefore we implemented a navigation mesh for the NPCs to use. By using this mesh instead of all the grid locations, the number of nodes in the planning graph was greatly reduced. In figure HENK an example of the navigation mesh can be seen. 


\section{Steering Behavior}
\label{sec:Steering Behavior}

The pathfinding plans a path around the static walls in the level. There are however a couple of dynamic objects in our world as well, e.g. the player and NPCs. Instead of making the pathplanning significantly more difficult, we use steering behaviors to avoid the dynamic obstacles. 

\subsection{Boids approach}
The first thing we tried was to implement a similar system to the Boids that were discussed in \citep{reynolds1987flocks}. The individuals were able to keep their distance, but it looked rather unnatural. Another problem with this approach was that sometimes one individual would push another away from its goal, while that other individual was pushing him. Thus both never reached their goals.

Because this didn't work out as we planned we tried another approach.

\subsection{Scanline approach}
The scanline approach employs raycasting to guide steering. Basically each person shoots three rays: 1 straight ahead, 1 tilted to the left and 1 tilted to the right. Based on which lines trigger, the heading direction is altered.

\section{Gameplay}
\label{sec:Gameplay}
Figure \ref{fig:gameplay} shows some typical gameplay. A bus appears on the left side of the screen heading west and lots of people are standing near the northern ATMs. The player, located in the bottom right corner of the screen, has to try and catch the bus before is leaves the screen. When dropping money on the street, people will try to pick thus blocking the road for the bus. This allows the player to get on the bus and drive off once the money is gone and the people walk away.

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_5336.png}
                \caption{Start of the game.}
                \label{fig:screenshot01}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_9475.png}
                \caption{Drop some money.}
                \label{fig:screenshot02}
        \end{subfigure}

        %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_18178.png}
                \caption{People gain interest.}
                \label{fig:screenshot03}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_23227.png}
                \caption{Drop some more money!}
                \label{fig:screenshot04}
        \end{subfigure}
        %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)

        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_31108.png}
                \caption{Get inside the bus and wait for people to leave.}
                \label{fig:screenshot05}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_62502.png}
                \caption{End of the game.}
                \label{fig:screenshot06}
        \end{subfigure}

        \caption{Typical gameplay}\label{fig:gameplay}
\end{figure}

\section{Discussion}
\label{sec:Discussion}

\section{Future Work}
\label{sec:Future Work}

\section{Conclusion}
\label{sec:Conclusion}

\bibliographystyle{plainnat}
\bibliography{references}

\end{document}