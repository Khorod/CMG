\documentclass[a4paper,pdf,12pt]{article}

\usepackage[utf8]{inputenc}

\usepackage{algorithmic}
\usepackage{amssymb}
\usepackage{tikz}

\usepackage{comment}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{multirow}

\usepackage{natbib}

\usepackage{graphicx}
\usepackage{array}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{rotating}

\usepackage[english]{babel}

\usepackage{url}
\usepackage[a4paper=true]{hyperref}
\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}


\title{Crowd Management Game\\ \normalsize{Game Programming}}
\author{Steven Laan\\UvAnetID: 6036031\\\url{S.Laan@uva.nl} \and Michael Cabot\\UvAnetID: 6047262\\\url{michael.cabot@uva.nl} \and Richard Rozeboom\\UvAnetID: 1337\\\url{R.R@awesome.nl}}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}

% TODO explain pygame

\section{Design}
\label{sec:Design}

\begin{figure}[h!]
\centering
\includegraphics[width = 1.0 \textwidth]{../img/player.png}
\caption{Player sprites.}
\label{fig:player}
\end{figure}

\section{Rendering}
\label{sec:Rendering}
% TODO tileset

\section{Collision Detection}
\label{sec:Collision Detection}
As soon as the rendering worked, we started on the collision detection. As you don't want your player to be able to walk through walls. Each sprite has a rectangle that represents the boundaries of the object. A collision is detected by determining whether there is an overlap between two rectangles. The overlap between two rectangles is calculated by TODO

An object is able to move in a direction if it does not result in a collision. If the object moves both horizontally and vertically, then the object is only moved in the direction that does not cause a collision. For example, an object that wants to move both upwards and to the right will only move upwards if there is a collision when moving to the right. This way an object can glide over a wall without the player explicitly having to hold only the valid keys. 

At first every collision was treated in a similar fashion. All objects in the game inherited from a superclass named GameObject, thus making collision detection easy because of polymorphism. However, because there were quite a couple of walls, it also made collision detection a tad slow. Therefore we implemented another system that is quite straightforward: whenever walls lie next to eachother merge them to create a bigger rectangle, on which the collisions are tested.

Thus there are 2 collision systems:
\begin{enumerate}
\item One system for GameObjects
\item One system for static wall collisions
\end{enumerate}

\section{Path Planning}
\label{sec:Path Planning}

After we created collision detection, we wanted to implement NPCs, non-playable characters. At first these character just walked in a straight line. As this is not very smart and does not get you anywhere, more advanced pathplanning had to be implemented. 

\subsection{Grid-based approach}
One of the simplest solutions was to work with the grid we already got for the collisions. Every point in this grid was connected to its direct neighbors in a graph. Now we could simply use A* to plan a path in this graph. 

The planning of a path involved converting the pixel position of an NPC to the corresponding tile position, as this was the level the collision map was defined on. Then the path could be planned in these tile positions and could be executed by the NPCs.

\subsection{Navigation Mesh}
The former solution did work, albeit it was a bit slow. As the goal was to simulate a crowd, slow pathfinding could really become a problem, when dealing with bigger crowds. Thus a more efficient solution had to be found.

Therefore we implemented a navigation mesh for the NPCs to use. By using this mesh instead of all the grid locations, the number of nodes in the planning graph was greatly reduced. In figure HENK an example of the navigation mesh can be seen. 


\section{Steering Behavior}
\label{sec:Steering Behavior}

The pathfinding plans a path around the static walls in the level. There are however a couple of dynamic objects in our world as well, e.g. the player and NPCs. Instead of making the pathplanning significantly more difficult, we use steering behaviors to avoid the dynamic obstacles. 

\subsection{Boids approach}
The first thing we tried was to implement a similar system to the Boids that were discussed in class\ref{Boidsding}. The individuals were able to keep their distance, but it looked rather unnatural. Another problem with this approach was that sometimes one individual would push another away from its goal, while that other individual was pushing him. Thus both never reached their goals.

Because this didn't work out as we planned we tried another approach.

\subsection{Scanline approach}
The scanline approach employs raycasting to guide steering. Basically each person shoots three rays: 1 straight ahead, 1 tilted to the left and 1 tilted to the right. Based on which lines trigger, the heading direction is altered.

\section{Gameplay}
\label{sec:Gameplay}

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_5336.png}
                \caption{Start of the game.}
                \label{fig:screenshot01}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_9475.png}
                \caption{Drop some money.}
                \label{fig:screenshot02}
        \end{subfigure}

        %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_18178.png}
                \caption{Some more money.}
                \label{fig:screenshot03}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_23227.png}
                \caption{More money!}
                \label{fig:screenshot04}
        \end{subfigure}
        %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)

        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_31108.png}
                \caption{Get inside the bus.}
                \label{fig:screenshot05}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.4\textwidth}
                \centering
                \includegraphics[width=\textwidth]{../screenshots/screenshot_62502.png}
                \caption{End of the game.}
                \label{fig:screenshot63}
        \end{subfigure}

        \caption{Typical gameplay}\label{fig:gameplay}
\end{figure}

\section{Discussion}
\label{sec:Discussion}

\section{Future Work}
\label{sec:Future Work}

\section{Conclusion}
\label{sec:Conclusion}

\bibliographystyle{plainnat}
\bibliography{references}

\end{document}